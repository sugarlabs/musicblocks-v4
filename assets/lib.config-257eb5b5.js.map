{"version":3,"file":"lib.config-257eb5b5.js","sources":["../../../lib/config/src/index.ts","../../../lib/config/src/utils.ts"],"sourcesContent":["import type { IComponent, TComponentId, TComponentManifest } from '#/@types/components';\nimport type { IElementSpecification } from '@sugarlabs/musicblocks-v4-lib';\n\nimport {\n    registerElementSpecificationEntries,\n    librarySpecification,\n} from '@sugarlabs/musicblocks-v4-lib';\n\n// -- private variables ----------------------------------------------------------------------------\n\n/** Stores key-value pairs of component identifier and component module. */\nconst _components: Partial<Record<TComponentId, IComponent>> = {};\n\n// -- private functions ----------------------------------------------------------------------------\n\n/**\n * Mounts a component module.\n * @param componentId component identifier\n */\nasync function _mountComponent(componentId: TComponentId): Promise<void> {\n    const component = _components[componentId]!;\n    await component.mount();\n}\n\n/**\n * Initializes a component module.\n * @param componentId component identifier\n */\nasync function _setupComponent(componentId: TComponentId): Promise<void> {\n    const component = _components[componentId]!;\n    await component.setup();\n}\n\n// -- public functions -----------------------------------------------------------------------------\n\n/**\n * Returns a component module by it's identifier.\n * @param componentId component identifier\n * @returns component module if valid identifier else `null`\n */\nexport function getComponent(componentId: TComponentId): IComponent | null {\n    return componentId in _components ? _components[componentId]! : null;\n}\n\n/**\n * Imports a component module.\n * @param componentId component identifier\n * @param path path to the module relative to `src/components`\n * @returns a Promise to the component's module\n */\nexport async function importComponent(\n    componentId: TComponentId,\n    importFunc: () => Promise<IComponent>,\n): Promise<IComponent> {\n    _components[componentId] = await importFunc();\n    return _components[componentId]!;\n}\n\n/**\n * Imports a list of component modules asynchronously.\n * @param componentIds list of component identifiers\n * @param callback callback function to call after succesful import of each component's module\n * @returns a Promise to the component module map\n */\nexport async function importComponents(\n    componentIds: TComponentId[],\n    componentManifest: TComponentManifest,\n    callback?: (componentId: TComponentId) => unknown,\n): Promise<Partial<Record<TComponentId, IComponent>>> {\n    Object.fromEntries(\n        await Promise.all(\n            componentIds\n                .map(\n                    (id) =>\n                        [id, componentManifest[id].importFunc] as [\n                            TComponentId,\n                            () => Promise<IComponent>,\n                        ],\n                )\n                .map(([id, importFunc]) =>\n                    importComponent(id, importFunc).then((component) => {\n                        if (callback !== undefined) callback(id);\n                        return [id, component];\n                    }),\n                ),\n        ),\n    );\n\n    return _components;\n}\n\n/**\n * Mounts a list of component modules synchronously.\n * @param entries list of tuples of component identifiers and feature flags\n * @param callback callback function to call after succesful mounting of each component\n */\nexport async function mountComponents(\n    componentIds: TComponentId[],\n    callback?: (componentId: TComponentId) => unknown,\n): Promise<void> {\n    return new Promise((resolve) => {\n        const iterator = componentIds.entries();\n\n        async function _mountHelper(\n            iteratorResult: IteratorResult<[number, TComponentId], unknown>,\n        ): Promise<void> {\n            if (iteratorResult.done) return;\n\n            const [_, componentId] = iteratorResult.value;\n            await _mountComponent(componentId);\n            if (callback !== undefined) callback(componentId);\n\n            return _mountHelper(iterator.next());\n        }\n\n        _mountHelper(iterator.next()).then(() => requestAnimationFrame(() => resolve()));\n    });\n}\n\n/**\n * Initializes a list of component modules synchronously.\n * @param componentIds list of component identifiers\n * @param callback callback function to call after succesful initialization of each component\n */\nexport async function setupComponents(\n    componentIds: TComponentId[],\n    callback?: (componentId: TComponentId) => unknown,\n): Promise<void> {\n    return new Promise((resolve) => {\n        const iterator = componentIds.entries();\n\n        async function _setupHelper(\n            iteratorResult: IteratorResult<[number, TComponentId], unknown>,\n        ): Promise<void> {\n            if (iteratorResult.done) return;\n\n            const [_, componentId] = iteratorResult.value;\n            await _setupComponent(componentId);\n            if (callback !== undefined) callback(componentId);\n\n            return _setupHelper(iterator.next());\n        }\n\n        _setupHelper(iterator.next()).then(() => requestAnimationFrame(() => resolve()));\n    });\n}\n\n/**\n * Registers syntax elements in the programming engine.\n * @param entries list of objects of component identifiers and corresponding syntax element filters\n */\nexport function registerElements(\n    entries: {\n        /** Component identifier. */\n        id: TComponentId;\n        /** List of syntax elements to register, or register all if `true`. */\n        filter: string[] | true | undefined;\n    }[],\n) {\n    registerElementSpecificationEntries(librarySpecification);\n\n    entries\n        .filter(({ filter }) => filter !== undefined)\n        .map(({ id, filter }) => {\n            if (filter === true) {\n                return { id, specification: _components[id]!.elements };\n            }\n\n            return {\n                id,\n                specification: Object.fromEntries(\n                    Object.entries(_components[id]!.elements!).filter(([elementName]) =>\n                        filter?.includes(elementName),\n                    ),\n                ),\n            };\n        })\n        .map(\n            ({ specification }) =>\n                specification as { [elementName: string]: IElementSpecification } | undefined,\n        )\n        .filter((specification) => specification !== undefined)\n        .forEach((specification) => registerElementSpecificationEntries(specification!));\n}\n","import type { TComponentId } from '#/@types/components';\n\n// -------------------------------------------------------------------------------------------------\n\n/**\n * Serializes components by dependency ordering using Topological Sorting.\n * @param components list of objects of component identifier and dependent component identifiers\n * @returns component identifiers in serialized order\n */\nexport function serializeComponentDependencies(\n    components: { id: TComponentId; dependencies: TComponentId[] }[],\n): TComponentId[] {\n    const length = components.length;\n\n    /**\n     * Generates a Directed Acyclic Graph (DAG) of the component indices.\n     * @returns a `nxn` matrix representing the DAG in adjacent list form\n     *\n     * @description\n     * Consider there are five components (`a`, `b`, `c`, `d`, `e`). `b` is child of `a`, `c` is\n     * child of `b`, `e` is child of `b` and `d`.\n     * The DAG will be:\n     * a <-- b <-- c\n     *       ^\n     *       |\n     * d <-- e\n     * The DAG matrix returned will be:\n     *   ____a_____b_____c_____d_____e____\n     * a | false false false false false |\n     * b |  true false false false false |\n     * c | false  true false false false |\n     * d | false false false false false |\n     * e | false  true false  true false |\n     *   ---------------------------------\n     * A cell (`row`, `col`) represents if component with index `row` is a child of component with\n     * index `col`.\n     */\n    const createDAG = () => {\n        const DAG = new Array<boolean[]>(length);\n\n        for (let i = 0; i < length; i++) {\n            const rowComponent = components[i];\n            DAG[i] = new Array<boolean>(length);\n            DAG[i].fill(false);\n\n            for (let j = 0; j < length; j++) {\n                const colComponent = components[j];\n\n                if (rowComponent.dependencies.includes(colComponent.id)) {\n                    DAG[i][j] = true;\n                }\n            }\n        }\n\n        return DAG;\n    };\n\n    const DAG = createDAG();\n\n    /**\n     * Serializes the generated DAG using Topological Sorting such that child component indices\n     * appear after their parent component indices in the ordering\n     * @returns a list of serialized indices of the DAG\n     *\n     * @description\n     * For the example above (function `createDAG` description), the result will be\n     * `[0, 3, 1, 2, 4]` representing component order [`a`, `d`, `b`, `c`, `e`].\n     */\n    const serializeDAG = () => {\n        let visited: number[] = [];\n        let visiting: number[] = [];\n        let unvisited: number[] = components.map((_, i) => i);\n\n        while (unvisited.length > 0) {\n            // find nodes with no parents\n            for (let i = 0; i < length; i++) {\n                let hasParents = false;\n\n                for (let j = 0; j < length; j++) {\n                    if (DAG[i][j] === true) {\n                        hasParents = true;\n                        break;\n                    }\n                }\n\n                // if node has no parents and node wasn't visited\n                if (!hasParents && !visited.includes(i)) {\n                    // add node to visitng list\n                    visiting.push(i);\n                    // remove node from unvisited list\n                    unvisited.splice(\n                        unvisited.findIndex((index) => index === i),\n                        1,\n                    );\n                }\n            }\n\n            // edge case for cyclic graph (or subgraph)\n            if (visiting.length === 0) {\n                throw Error('Invalid Config: dependency resolution results in a cyclic graph');\n            }\n\n            // for visiting nodes in order\n            for (const index of visiting) {\n                // add node to visited list\n                visited.push(index);\n\n                // remove all edges (in DAG) to node\n                for (let j = 0; j < length; j++) {\n                    DAG[j][index] = false;\n                }\n            }\n\n            // clear visiting list\n            visiting = [];\n        }\n\n        return visited;\n    };\n\n    const serializedIndices = serializeDAG();\n\n    return serializedIndices.map((i) => components[i].id);\n}\n\n// -------------------------------------------------------------------------------------------------\n\n/*\n * dummy config to debug valid topological sorting\n *   a <-- b <-- c\n *         ^\n *         |\n *   d <-- e\n */\n\n// serializeComponentDependencies([\n//     // @ts-ignore\n//     { id: 'a', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'b', dependencies: ['a'] },\n//     // @ts-ignore\n//     { id: 'c', dependencies: ['b'] },\n//     // @ts-ignore\n//     { id: 'd', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'e', dependencies: ['b', 'd'] },\n// ]).forEach((componentId) => console.log(componentId));\n\n/*\n * dummy config to debug invalid (cycle in `b`, `c`, `e`) topological sorting\n *   a <-- b <-- c\n *         |     ^\n *         v     |\n *   d <-- e ----\n */\n\n// serializeComponentDependencies([\n//     // @ts-ignore\n//     { id: 'a', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'b', dependencies: ['e'] },\n//     // @ts-ignore\n//     { id: 'c', dependencies: ['b'] },\n//     // @ts-ignore\n//     { id: 'd', dependencies: [] },\n//     // @ts-ignore\n//     { id: 'e', dependencies: ['d', 'd'] },\n// ]).forEach((componentId) => console.log(componentId));\n"],"names":["_components","_mountComponent","componentId","_setupComponent","getComponent","importComponent","importFunc","importComponents","componentIds","componentManifest","callback","id","component","mountComponents","resolve","iterator","_mountHelper","iteratorResult","_","setupComponents","_setupHelper","registerElements","entries","registerElementSpecificationEntries","librarySpecification","filter","elementName","specification","serializeComponentDependencies","components","length","DAG","rowComponent","j","colComponent","visited","visiting","unvisited","i","hasParents","index"],"mappings":"wCAWA,MAAMA,EAAyD,CAAA,EAQ/D,eAAeC,EAAgBC,EAA0C,CAErE,MADkBF,EAAYE,CAAW,EACzB,OACpB,CAMA,eAAeC,EAAgBD,EAA0C,CAErE,MADkBF,EAAYE,CAAW,EACzB,OACpB,CASO,SAASE,EAAaF,EAA8C,CACvE,OAAOA,KAAeF,EAAcA,EAAYE,CAAW,EAAK,IACpE,CAQsB,eAAAG,EAClBH,EACAI,EACmB,CACP,OAAAN,EAAAE,CAAW,EAAI,MAAMI,IAC1BN,EAAYE,CAAW,CAClC,CAQsB,eAAAK,EAClBC,EACAC,EACAC,EACkD,CAC3C,cAAA,YACH,MAAM,QAAQ,IACVF,EACK,IACIG,GACG,CAACA,EAAIF,EAAkBE,CAAE,EAAE,UAAU,CAAA,EAK5C,IAAI,CAAC,CAACA,EAAIL,CAAU,IACjBD,EAAgBM,EAAIL,CAAU,EAAE,KAAMM,IAC9BF,IAAa,QAAWA,EAASC,CAAE,EAChC,CAACA,EAAIC,CAAS,EACxB,CACL,CACR,CAAA,EAGGZ,CACX,CAOsB,eAAAa,EAClBL,EACAE,EACa,CACN,OAAA,IAAI,QAASI,GAAY,CACtB,MAAAC,EAAWP,EAAa,UAE9B,eAAeQ,EACXC,EACa,CACb,GAAIA,EAAe,KAAM,OAEzB,KAAM,CAACC,EAAGhB,CAAW,EAAIe,EAAe,MACxC,aAAMhB,EAAgBC,CAAW,EAC7BQ,IAAa,QAAWA,EAASR,CAAW,EAEzCc,EAAaD,EAAS,KAAA,CAAM,CACvC,CAEaC,EAAAD,EAAS,KAAK,CAAC,EAAE,KAAK,IAAM,sBAAsB,IAAMD,EAAS,CAAA,CAAC,CAAA,CAClF,CACL,CAOsB,eAAAK,EAClBX,EACAE,EACa,CACN,OAAA,IAAI,QAASI,GAAY,CACtB,MAAAC,EAAWP,EAAa,UAE9B,eAAeY,EACXH,EACa,CACb,GAAIA,EAAe,KAAM,OAEzB,KAAM,CAACC,EAAGhB,CAAW,EAAIe,EAAe,MACxC,aAAMd,EAAgBD,CAAW,EAC7BQ,IAAa,QAAWA,EAASR,CAAW,EAEzCkB,EAAaL,EAAS,KAAA,CAAM,CACvC,CAEaK,EAAAL,EAAS,KAAK,CAAC,EAAE,KAAK,IAAM,sBAAsB,IAAMD,EAAS,CAAA,CAAC,CAAA,CAClF,CACL,CAMO,SAASO,EACZC,EAMF,CACEC,EAAA,oCAAoCC,EAAoB,oBAAA,EAExDF,EACK,OAAO,CAAC,CAAE,OAAAG,CAAa,IAAAA,IAAW,MAAS,EAC3C,IAAI,CAAC,CAAE,GAAAd,EAAI,OAAAc,KACJA,IAAW,GACJ,CAAE,GAAAd,EAAI,cAAeX,EAAYW,CAAE,EAAG,UAG1C,CACH,GAAAA,EACA,cAAe,OAAO,YAClB,OAAO,QAAQX,EAAYW,CAAE,EAAG,QAAS,EAAE,OAAO,CAAC,CAACe,CAAW,IAC3DD,GAAA,YAAAA,EAAQ,SAASC,EACrB,CACJ,CAAA,CAEP,EACA,IACG,CAAC,CAAE,cAAAC,CAAA,IACCA,CAEP,EAAA,OAAQA,GAAkBA,IAAkB,MAAS,EACrD,QAASA,GAAkBJ,sCAAoCI,CAAc,CAAC,CACvF,CC9KO,SAASC,EACZC,EACc,CACd,MAAMC,EAASD,EAAW,OA6CpBE,GApBY,IAAM,CACdA,MAAAA,EAAM,IAAI,MAAiBD,CAAM,EAEvC,QAAS,EAAI,EAAG,EAAIA,EAAQ,IAAK,CACvB,MAAAE,EAAeH,EAAW,CAAC,EACjCE,EAAI,CAAC,EAAI,IAAI,MAAeD,CAAM,EAClCC,EAAI,CAAC,EAAE,KAAK,EAAK,EAEjB,QAASE,EAAI,EAAGA,EAAIH,EAAQG,IAAK,CACvB,MAAAC,EAAeL,EAAWI,CAAC,EAE7BD,EAAa,aAAa,SAASE,EAAa,EAAE,IAClDH,EAAI,CAAC,EAAEE,CAAC,EAAI,KAKjBF,OAAAA,CAAA,KAoEX,OAtDqB,IAAM,CACvB,IAAII,EAAoB,CAAA,EACpBC,EAAqB,CAAA,EACrBC,EAAsBR,EAAW,IAAI,CAACX,EAAGoB,IAAMA,CAAC,EAE7C,KAAAD,EAAU,OAAS,GAAG,CAEzB,QAASC,EAAI,EAAGA,EAAIR,EAAQQ,IAAK,CAC7B,IAAIC,EAAa,GAEjB,QAASN,EAAI,EAAGA,EAAIH,EAAQG,IACxB,GAAIF,EAAIO,CAAC,EAAEL,CAAC,IAAM,GAAM,CACPM,EAAA,GACb,MAKJ,CAACA,GAAc,CAACJ,EAAQ,SAASG,CAAC,IAElCF,EAAS,KAAKE,CAAC,EAELD,EAAA,OACNA,EAAU,UAAWG,GAAUA,IAAUF,CAAC,EAC1C,CAAA,GAMR,GAAAF,EAAS,SAAW,EACpB,MAAM,MAAM,iEAAiE,EAIjF,UAAWI,KAASJ,EAAU,CAE1BD,EAAQ,KAAKK,CAAK,EAGlB,QAASP,EAAI,EAAGA,EAAIH,EAAQG,IACpBF,EAAAE,CAAC,EAAEO,CAAK,EAAI,GAKxBJ,EAAW,CAAA,EAGR,OAAAD,CAAA,KAKc,IAAKG,GAAMT,EAAWS,CAAC,EAAE,EAAE,CACxD"}